## 1. 前言

根据Ratis140中所描述的

```
Another problem we fix here is: when the client fails over to from an old leader to a new leader, the client should send retries in the same order.
```

这句话出现在r140_20171204.patch之后，那么相关的代码改动就是为了解决这个问题的。

### 1. 有关Client类中的两个first实例变量

* firstSeqNum用来标识第一个请求的seqNum
* firstReplied用来标识第一个请求是否已经得到了回复

关于这两个实例变量的处理逻辑主要在sendOrDelayRequest()方法中。

入口方法灾害submitNewRequest()方法中，该方法首先构造REQUEST请求，将该请求放入RequestMap中等待发送。具体选择立即发送还是推迟发送的逻辑在sendOrDelayRequest()方法中

```java
/**
     * A new request arrives, create it with {@link #nextSeqNum}
     * and then try sending it to the server.
     *
     * @param requestConstructor use seqNum to create a new request.
     * @return the new request.
     */
    public synchronized REQUEST submitNewRequest(
        LongFunction<REQUEST> requestConstructor, Consumer<REQUEST> sendMethod) {
      if (!requests.isEmpty()) {
        Preconditions.assertTrue(nextSeqNum == requests.lastSeqNum() + 1,
            () -> "nextSeqNum=" + nextSeqNum + " but " + this);
      }

      final long seqNum = nextSeqNum++;
      final REQUEST r = requestConstructor.apply(seqNum);
      requests.putNewRequest(r);

      final boolean submitted = sendOrDelayRequest(r, sendMethod);
      LOG.debug("{}: submitting a new request {} in {}? {}",
          requests.getName(), r, this, submitted? "submitted": "delayed");
      return r;
    }

    private boolean sendOrDelayRequest(REQUEST request, Consumer<REQUEST> sendMethod) {
      final long seqNum = request.getSeqNum();
      Preconditions.assertTrue(requests.getNonRepliedRequest(seqNum, "sendOrDelayRequest") == request);

      if (firstReplied) {
        // already received the reply for the first request, submit any request.
        sendMethod.accept(request);
        return true;
      }

      if (firstSeqNum == -1 && seqNum == requests.firstSeqNum()) {
        // first request is not yet submitted and this is the first request, submit it.
        LOG.debug("{}: detect firstSubmitted {} in {}", requests.getName(), request, this);
        firstSeqNum = seqNum;
        sendMethod.accept(request);
        return true;
      }

      // delay other requests
      CollectionUtils.putNew(seqNum, seqNum, delayedRequests, () -> requests.getName() + ":delayedRequests");
      return false;
    }
```

sendOrDelayRequest()方法首先判断第一个请求是否已经得到了leader的回复，如果得到了，那么可以将该请求直接发送；否则判断该请求是否为第一个请求，判断的逻辑有两个：首先，firstSeqNum处在复位的状态，其次，该请求是requestsMap中的第一个请求，如果满足这两个条件，说明该请求是第一个请求，那么可以将该请求直接发送；否则，将请求放入延迟队列中。

这样的代码逻辑是因为client在发送request的过程中，很有可能发生leader的fail over。需要注意的是，leader也是使用SlidingWindow对接收到的request进行按序处理，按序回复，即便如此，依旧会出现reply乱序到达的情况。

假设：

1. leader将reply1 reply2 reply3按序发送给了client
2. 由于reply1 reply2 reply3走的不同的路由，那么在客户端侧，依旧会出现响应乱序到达的情况
3. client按照reply2 reply1 reply3的顺序收到了响应

假设reply2 reply1 reply3均为NotLeaderException，那么分别会调用resetFirstSeqNum()方法，不对，应该只有reply1为NotLeaderException，这部分的逻辑在哪里呢？？？？

这部分要看RaftClient，RaftClientImpl调用sendRequestAsync()方法啊，该方法返回一个CompletableFuture对象，处理reply的逻辑在thenApply()方法中

```java
private CompletableFuture<RaftClientReply> sendRequestAsync(
      RaftClientRequest request) {
    LOG.debug("{}: send* {}", clientId, request);
    return clientRpc.sendRequestAsync(request).thenApply(reply -> {
      LOG.debug("{}: receive* {}", clientId, reply);
      reply = handleNotLeaderException(request, reply);
      if (reply != null) {
        getSlidingWindow(request).receiveReply(
            request.getSeqNum(), reply, this::sendRequestWithRetryAsync);
      }
      return reply;
    }).exceptionally(e -> {
      LOG.debug("{}: Failed {} with {}", clientId, request, e);
      e = JavaUtils.unwrapCompletionException(e);
      if (e instanceof GroupMismatchException) {
        throw new CompletionException(e);
      } else if (e instanceof IOException) {
        handleIOException(request, (IOException)e, null);
      } else {
        throw new CompletionException(e);
      }
      return null;
    });
  }
```

可以看到，在收到leader的reply之后，首先要判断是否发生了NotLeaderException的情况，处理逻辑在handleNotLeaderException()方法中

```java
/**
   * @return null if the reply is null or it has {@link NotLeaderException};
   *         otherwise return the same reply.
   */
  private RaftClientReply handleNotLeaderException(RaftClientRequest request, RaftClientReply reply) {
    if (reply == null) {
      return null;
    }
    final NotLeaderException nle = reply.getNotLeaderException();
    if (nle == null) {
      return reply;
    }
    refreshPeers(Arrays.asList(nle.getPeers()));
    final RaftPeerId newLeader = nle.getSuggestedLeader() == null ? null
        : nle.getSuggestedLeader().getId();
    handleIOException(request, nle, newLeader);
    return null;
  }

  private void handleIOException(RaftClientRequest request, IOException ioe,
      RaftPeerId newLeader) {
    LOG.debug("{}: suggested new leader: {}. Failed {} with {}",
        clientId, newLeader, request, ioe);
    if (LOG.isTraceEnabled()) {
      LOG.trace("Stack trace", new Throwable("TRACE"));
    }

    getSlidingWindow(request).resetFirstSeqNum();
    if (ioe instanceof LeaderNotReadyException) {
      return;
    }

    final RaftPeerId oldLeader = request.getServerId();
    final boolean stillLeader = oldLeader.equals(leaderId);
    if (newLeader == null && stillLeader) {
      newLeader = CollectionUtils.random(oldLeader,
          CollectionUtils.as(peers, RaftPeer::getId));
    }

    final boolean changeLeader = newLeader != null && stillLeader;
    if (changeLeader) {
      LOG.debug("{}: change Leader from {} to {}", clientId, oldLeader, newLeader);
      this.leaderId = newLeader;
    }
    clientRpc.handleException(oldLeader, ioe, changeLeader);
  }
```

